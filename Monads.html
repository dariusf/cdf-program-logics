<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Monads.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="doc">
Hoare monads and Dijkstra monads 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk0"><span class="kn">From</span> Coq <span class="kn">Require Import</span> Program ZArith.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file extraction_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> CDF <span class="kn">Require</span> Hoare Separation Delay.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">inv</span> H := <span class="nb">inversion</span> H; <span class="nb">clear</span> H; <span class="nb">subst</span>.</span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Hoare monads</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab2"></a><h2 class="section">The generic interface</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module Type</span> <span class="nf">HOAREMONAD</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">PRE</span>: <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">M</span>: <span class="kr">forall</span> (<span class="nv">P</span>: PRE) (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">Q</span>: POST A), <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">ret</span>:
    <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">Q</span>: POST A) (<span class="nv">v</span>: A), M (Q v) A Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">bind</span>:
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">R</span>: POST B),
           M P A Q -&gt; (<span class="kr">forall</span> (<span class="nv">v</span>: A), M (Q v) B R) -&gt; M P B R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">implies</span>: PRE -&gt; PRE -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">consequence_pre</span>:
    <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span>: POST A),
           implies P&#39; P -&gt; M P A Q -&gt; M P&#39; A Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">consequence_post</span>:
    <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A),
           (<span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v))-&gt; M P A Q -&gt; M P A Q&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">HOAREMONAD</span>.</span></span></pre><div class="doc">
<a id="lab3"></a><h2 class="section">The Hoare monad of pure computations</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">HPure</span> &lt;: HOAREMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">P</span>: PRE) (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">Q</span>: POST A) := P -&gt; { a : A | Q a }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">Q</span>: POST A) (<span class="nv">v</span>: A) : M (Q v) A Q :=
  <span class="kr">fun</span> <span class="nv">p</span> =&gt; exist _ v p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
                (<span class="nv">P</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">R</span>: POST B)
                (<span class="nv">a</span>: M P A Q) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M (Q v) B R) : M P B R :=
  <span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="kr">let</span> &#39;(exist _ b r) := a p <span class="kr">in</span> f b r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">implies</span> (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) := P -&gt; P&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">consequence_pre</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">IMP</span>: implies P&#39; P) (<span class="nv">m</span>: M P A Q) : M P&#39; A Q :=
  <span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; m (IMP p&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">consequence_post</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A) (<span class="nv">IMP</span>: <span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v)) (<span class="nv">m</span>: M P A Q) : M P A Q&#39; :=
  <span class="kr">fun</span> <span class="nv">p</span> =&gt; m p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q&#39; (` (m p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2"><span class="nb">destruct</span> (m p); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IMP; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">HPure</span>.</span></span></pre><div class="doc">
<a id="lab4"></a><h2 class="section">The Hoare monad of possibly-diverging computations</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">HDiv</span> &lt;: HOAREMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Delay.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">P</span>: PRE) (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">Q</span>: POST A) := P -&gt; { d : delay A | safe Q d }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">Q</span>: POST A) (<span class="nv">v</span>: A) : M (Q v) A Q :=
  <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="bp">now</span> v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk3"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Q v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (<span class="bp">now</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">BIND</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
        (<span class="nv">P</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">R</span>: POST B)
        (<span class="nv">a</span>: M P A Q) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M (Q v) B R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">bind_aux</span> (<span class="nv">d</span>: delay A) : safe Q d -&gt; delay B :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | <span class="bp">now</span> v =&gt; <span class="kr">fun</span> <span class="nv">SAFE</span> =&gt; later (proj1_sig (f v (safe_inv_now _ _ SAFE)))
  | later d =&gt; <span class="kr">fun</span> <span class="nv">SAFE</span> =&gt; later (bind_aux d (safe_inv_later _ _ SAFE))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4"><span class="kn">Lemma</span> <span class="nf">safe_bind_aux</span>:
  <span class="kr">forall</span> (<span class="nv">d</span>: delay A) (<span class="nv">s</span>: safe Q d), safe R (bind_aux d s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d),
safe R (bind_aux d s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d),
safe R (bind_aux d s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk6"><span class="kr">cofix</span> COH; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (bind_aux d s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk7">unroll_delay (bind_aux d s); <span class="nb">destruct</span> d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q (<span class="bp">now</span> a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (later (` (f a0 (safe_inv_now Q a0 s))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q (later d)</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk8"><hr></label><div class="goal-conclusion">safe R (later (bind_aux d (safe_inv_later Q d s)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q (<span class="bp">now</span> a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (later (` (f a0 (safe_inv_now Q a0 s))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chka"><span class="nb">destruct</span> (f a0 (safe_inv_now Q a0 s)) <span class="kr">as</span> (d1 &amp; s1); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q (<span class="bp">now</span> a0)</span></span></span><br><span><var>d1</var><span class="hyp-type"><b>: </b><span>delay B</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>safe R d1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (later d1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q (later d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (later (bind_aux d (safe_inv_later Q d s)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chkc"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>COH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay A) (<span class="nv">s</span> : safe Q d), safe R (bind_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q (later d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (bind_aux d (safe_inv_later Q d s))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> COH.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind</span> : M P B R :=
  <span class="kr">fun</span> <span class="nv">p</span> =&gt; <span class="kr">let</span> &#39;(exist _ d s) := a p <span class="kr">in</span> exist _ (bind_aux d s) (safe_bind_aux d s).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">BIND</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">implies</span> (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) := P -&gt; P&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">consequence_pre</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">IMP</span>: implies P&#39; P) (<span class="nv">m</span>: M P A Q) : M P&#39; A Q :=
  <span class="kr">fun</span> <span class="nv">p&#39;</span> =&gt; m (IMP p&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">consequence_post</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A) (<span class="nv">IMP</span>: <span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v)) (<span class="nv">m</span>: M P A Q) : M P A Q&#39; :=
  <span class="kr">fun</span> <span class="nv">p</span> =&gt; m p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chkd"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q&#39; (` (m p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chke"><span class="nb">destruct</span> (m p); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>delay A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe Q x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> safe_consequence <span class="kr">with</span> Q; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
A specific operation of the DIV monad: a <span class="inlinecode"><span class="id" title="tactic">repeat</span>...<span class="id" title="tactic">until</span></span> unbounded loop.
   <span class="inlinecode"><span class="id" title="var">iter</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is such that

<div class="paragraph"> </div>
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">iter</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> if <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> terminates with <span class="inlinecode"><span class="id" title="var">inr</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>
</li>
<li> <span class="inlinecode"><span class="id" title="var">iter</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">iter</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x'</span></span> if <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> terminates with <span class="inlinecode"><span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">x'</span></span>.

</li>
</ul>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ITER</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: A -&gt; PRE) (<span class="nv">Q</span>: POST B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">R</span> : POST (A + B) := <span class="kr">fun</span> <span class="nv">ab</span> =&gt; <span class="kr">match</span> ab <span class="kr">with</span> inl a =&gt; P a | inr b =&gt; Q b <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">a</span>: A), M (P a) (A + B) R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">iter_aux</span> (<span class="nv">d</span>: delay (A + B)) : safe R d -&gt; delay B :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | <span class="bp">now</span> (inl a) =&gt; <span class="kr">fun</span> <span class="nv">SAFE</span> =&gt; <span class="kr">let</span> &#39;(exist _ d&#39; s&#39;) := f a (safe_inv_now _ _ SAFE) <span class="kr">in</span> later (iter_aux d&#39; s&#39;)
  | <span class="bp">now</span> (inr b) =&gt; <span class="kr">fun</span> <span class="nv">SAFE</span> =&gt; <span class="bp">now</span> b
  | later d =&gt; <span class="kr">fun</span> <span class="nv">SAFE</span> =&gt; later (iter_aux d (safe_inv_later _ _ SAFE))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chkf"><span class="kn">Lemma</span> <span class="nf">safe_iter_aux</span>:
  <span class="kr">forall</span> (<span class="nv">d</span>: delay (A + B)) (<span class="nv">s</span>: safe R d), safe Q (iter_aux d s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk11"><span class="kr">cofix</span> COINDHYP; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay (A + B)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (iter_aux d s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk12">unroll_delay (iter_aux d s); <span class="nb">destruct</span> d <span class="kr">as</span> [[a | b] | d].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (<span class="bp">now</span> (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q
  <span class="kr">match</span>
    (<span class="kr">let</span>
     <span class="nv">&#39;exist</span> <span class="nv">_</span> <span class="nv">d&#39;</span> <span class="nv">s&#39;</span> := f a (safe_inv_now R (inl a) s)
      <span class="kr">in</span> later (iter_aux d&#39; s&#39;))
  <span class="kr">with</span>
  | <span class="bp">now</span> v =&gt; <span class="bp">now</span> v
  | later y =&gt; later y
  <span class="kr">end</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (<span class="bp">now</span> (inr b))</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk13"><hr></label><div class="goal-conclusion">safe Q (<span class="bp">now</span> b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Monads-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay (A + B)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (later d)</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk14"><hr></label><div class="goal-conclusion">safe Q (later (iter_aux d (safe_inv_later R d s)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (<span class="bp">now</span> (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q
  <span class="kr">match</span>
    (<span class="kr">let</span>
     <span class="nv">&#39;exist</span> <span class="nv">_</span> <span class="nv">d&#39;</span> <span class="nv">s&#39;</span> := f a (safe_inv_now R (inl a) s)
      <span class="kr">in</span> later (iter_aux d&#39; s&#39;))
  <span class="kr">with</span>
  | <span class="bp">now</span> v =&gt; <span class="bp">now</span> v
  | later y =&gt; later y
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk16"><span class="nb">destruct</span> f <span class="kr">as</span> [ab&#39; s&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (<span class="bp">now</span> (inl a))</span></span></span><br><span><var>ab'</var><span class="hyp-type"><b>: </b><span>delay (A + B)</span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>safe R ab&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (later (iter_aux ab&#39; s&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk17"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (<span class="bp">now</span> (inl a))</span></span></span><br><span><var>ab'</var><span class="hyp-type"><b>: </b><span>delay (A + B)</span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>safe R ab&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (iter_aux ab&#39; s&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> COINDHYP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (<span class="bp">now</span> (inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (<span class="bp">now</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk19"><span class="nb">apply</span> safe_inv_now <span class="kr">in</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>R (inr b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (<span class="bp">now</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1a"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>R (inr b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay (A + B)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (later d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (later (iter_aux d (safe_inv_later R d s)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1c"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>COINDHYP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">d</span> : delay (A + B)) (<span class="nv">s</span> : safe R d),
safe Q (iter_aux d s)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>delay (A + B)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>safe R (later d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q (iter_aux d (safe_inv_later R d s))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> COINDHYP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">iter</span> (<span class="nv">x</span>: A) : M (P x) B Q :=
  <span class="kr">fun</span> <span class="nv">p</span> =&gt; iter_aux (<span class="bp">now</span> (inl x)) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1d"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe R (<span class="bp">now</span> (inl x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1e"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (inl x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk1f"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>R</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">ab</span> : A + B =&gt;
<span class="kr">match</span> ab <span class="kr">with</span>
| inl a =&gt; P a
| inr b =&gt; Q b
<span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span>POST (A + B)</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, M (P a) (A + B) R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">safe Q
  (iter_aux (<span class="bp">now</span> (inl x)) (iter_obligation_1 x p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> safe_iter_aux.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ITER</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">HDiv</span>.</span></span></pre><div class="doc">
<a id="lab5"></a><h2 class="section">The Hoare monad for mutable state</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">HST</span> &lt;: HOAREMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Separation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := heap -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">P</span>: PRE) (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">Q</span>: POST A) : <span class="kt">Type</span> :=
  <span class="kr">forall</span> <span class="nv">h</span>, P h -&gt; { a_h : A * heap | Q (fst a_h) (snd a_h) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">Q</span>: POST A) (<span class="nv">v</span>: A) : M (Q v) A Q
  := <span class="kr">fun</span> <span class="nv">h</span> <span class="nv">_</span> =&gt; (v, h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
  (<span class="nv">P</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">R</span>: POST B)
  (<span class="nv">a</span>: M P A Q) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M (Q v) B R) : M P B R :=
  <span class="kr">fun</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; <span class="kr">let</span> &#39;(v, h&#39;) := a h p <span class="kr">in</span> f v h&#39; _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk20"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>(v, h&#39;) = ` (a h p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk21"><span class="nb">destruct</span> (a h p) <span class="kr">as</span> [[v1 h1] p1]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>Q v1 h1</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>(v, h&#39;) = (v1, h1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk22">inv Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M (Q v) B R</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>Q v1 h1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v1 h1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">implies</span> (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) := P --&gt;&gt; P&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">consequence_pre</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">IMP</span>: implies P&#39; P) (<span class="nv">m</span>: M P A Q) : M P&#39; A Q :=
  <span class="kr">fun</span> <span class="nv">h</span> <span class="nv">p&#39;</span> =&gt; m h (IMP h p&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">consequence_post</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A) (<span class="nv">IMP</span>: <span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v)) (<span class="nv">m</span>: M P A Q) : M P A Q&#39; :=
  <span class="kr">fun</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; m h p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk23"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q&#39; (fst (` (m h p))) (snd (` (m h p)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk24"><span class="nb">destruct</span> (m h p) <span class="kr">as</span> [[v h&#39;] q]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q (fst (v, h&#39;)) (snd (v, h&#39;))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q&#39; v h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IMP; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">consequence</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A)
               (<span class="nv">IMP1</span>: implies P&#39; P) (<span class="nv">IMP2</span>: <span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v)) (<span class="nv">m</span>: M P A Q) : M P&#39; A Q&#39; :=
  consequence_pre _ _ _ IMP1 (consequence_post _ _ _ IMP2 m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">get</span> (<span class="nv">l</span>: addr) : 
  <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">R</span>, M (contains l v ** R) Z (<span class="kr">fun</span> <span class="nv">v&#39;</span> =&gt; (v&#39; = v) //\\ contains l v ** R) :=
  <span class="kr">fun</span> <span class="nv">v</span> <span class="nv">R</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; <span class="kr">match</span> h l <span class="kr">with</span> Some v&#39; =&gt; (v&#39;, h) | None =&gt; _ <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk25"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(contains l v ** R) h</span></span></span><br><span><var>v'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v&#39; = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((v&#39; = v) //\\ contains l v ** R) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk26"><span class="nb">split</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(contains l v ** R) h</span></span></span><br><span><var>v'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v&#39; = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v&#39; = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk27"><span class="nb">destruct</span> p <span class="kr">as</span> (h1 &amp; h2 &amp; p1 &amp; p2 &amp; D &amp; U).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>v'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v&#39; = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v&#39; = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk28"><span class="nb">rewrite</span> U <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>v'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v&#39; = hunion h1 h2 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v&#39; = v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk29"><span class="nb">cbn</span> <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>v'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v&#39; =
(<span class="kr">if</span> h1 l <span class="kr">then</span> h1 l <span class="kr">else</span> h2 l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v&#39; = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2a"><span class="nb">rewrite</span> ! p1, hupdate_same <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>v'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v&#39; = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v&#39; = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2b"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(contains l v ** R) h</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a_h : Z * heap
| ((fst a_h = v) //\\ contains l v ** R) (snd a_h)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2c"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(contains l v ** R) h</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2d"><span class="nb">destruct</span> p <span class="kr">as</span> (h1 &amp; h2 &amp; p1 &amp; p2 &amp; D &amp; U).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2e"><span class="nb">rewrite</span> U <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = hunion h1 h2 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk2f"><span class="nb">cbn</span> <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = (<span class="kr">if</span> h1 l <span class="kr">then</span> h1 l <span class="kr">else</span> h2 l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk30"><span class="nb">rewrite</span> ! p1, hupdate_same <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">set</span> (<span class="nv">l</span>: addr) (<span class="nv">v</span>: Z) :
  <span class="kr">forall</span> <span class="nv">R</span>, M (valid l ** R) unit (<span class="kr">fun</span> <span class="nv">_</span> =&gt; contains l v ** R) :=
  <span class="kr">fun</span> <span class="nv">R</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; (tt, hupdate l v h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk31"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(valid l ** R) h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(contains l v ** R) (hupdate l v h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk32"><span class="nb">destruct</span> p <span class="kr">as</span> (h1 &amp; h2 &amp; p1 &amp; p2 &amp; D &amp; U).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>valid l h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(contains l v ** R) (hupdate l v h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk33"><span class="nb">destruct</span> p1 <span class="kr">as</span> (v0 &amp; p1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion h1 h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(contains l v ** R) (hupdate l v h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk34"><span class="nb">rewrite</span> p1 <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(contains l v ** R) (hupdate l v h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk35"><span class="kr">exists</span> (<span class="nv">hupdate</span> <span class="nv">l</span> <span class="nv">v</span> <span class="nv">hempty</span>), h2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">contains l v (hupdate l v hempty) /\
R h2 /\
hdisjoint (hupdate l v hempty) h2 /\
hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk36"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">contains l v (hupdate l v hempty)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk37"><hr></label><div class="goal-conclusion">R h2 /\
hdisjoint (hupdate l v hempty) h2 /\
hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk38"><span class="nb">red</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h2 /\
hdisjoint (hupdate l v hempty) h2 /\
hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk39"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R h2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk3a"><hr></label><div class="goal-conclusion">hdisjoint (hupdate l v hempty) h2 /\
hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk3b"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hdisjoint (hupdate l v hempty) h2 /\
hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk3c"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hdisjoint (hupdate l v hempty) h2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk3d"><hr></label><div class="goal-conclusion">hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk3e"><span class="nb">red</span>; <span class="nb">intros</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v <span class="kr">else</span> None) = None \/
h2 x = None</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk3f"><hr></label><div class="goal-conclusion">hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk40"><span class="nb">specialize</span> (D x); <span class="nb">cbn</span> <span class="kr">in</span> D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v0 <span class="kr">else</span> None) = None \/
h2 x = None</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v <span class="kr">else</span> None) = None \/
h2 x = None</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Monads-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><label class="goal-separator" for="Monads-v-chk41"><hr></label><div class="goal-conclusion">hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk42"><span class="nb">destruct</span> (Z.eq_dec l x); <span class="nb">intuition</span> <span class="bp">congruence</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hupdate l v h = hunion (hupdate l v hempty) h2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk43"><span class="nb">rewrite</span> U.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hupdate l v (hunion (hupdate l v0 hempty) h2) =
hunion (hupdate l v hempty) h2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk44"><span class="nb">apply</span> heap_extensionality; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hupdate l v (hunion (hupdate l v0 hempty) h2) x =
hunion (hupdate l v hempty) h2 x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk45"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>h, h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>contains l v0 h1</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>R h2</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>hdisjoint (hupdate l v0 hempty) h2</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>h = hunion (hupdate l v0 hempty) h2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> Z.eq_dec l x
 <span class="kr">then</span> Some v
 <span class="kr">else</span>
  <span class="kr">if</span> <span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v0 <span class="kr">else</span> None
  <span class="kr">then</span> <span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v0 <span class="kr">else</span> None
  <span class="kr">else</span> h2 x) =
(<span class="kr">if</span> <span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v <span class="kr">else</span> None
 <span class="kr">then</span> <span class="kr">if</span> Z.eq_dec l x <span class="kr">then</span> Some v <span class="kr">else</span> None
 <span class="kr">else</span> h2 x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Z.eq_dec l x); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">HST</span>.</span></span></pre><div class="doc">
<a id="lab6"></a><h2 class="section">The Hoare monad for mutable state in separation logic style</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">HSep</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Separation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := heap -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">P</span>: PRE) (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">Q</span>: POST A) : <span class="kt">Type</span> :=
  <span class="kr">forall</span> (<span class="nv">R</span>: assertion), HST.M (P ** R) A (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q v ** R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">Q</span>: POST A) (<span class="nv">v</span>: A) : M (Q v) A Q :=
  <span class="kr">fun</span> <span class="nv">R</span> =&gt; HST.ret (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q v ** R) v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>}
  (<span class="nv">P</span>: assertion) (<span class="nv">Q</span>: A -&gt; assertion) (<span class="nv">R</span>: B -&gt; assertion)
  (<span class="nv">a</span>: M P A Q) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M (Q v) B R) : M P B R :=
  <span class="kr">fun</span> <span class="nv">F</span> =&gt; HST.bind (P ** F) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q v ** F) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; R v ** F)
                        (a F) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; f v F).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">implies</span> (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) := P --&gt;&gt; P&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">consequence_pre</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">IMP</span>: implies P&#39; P) (<span class="nv">m</span>: M P A Q) : M P&#39; A Q :=
  <span class="kr">fun</span> <span class="nv">R</span> =&gt; HST.consequence_pre (P ** R) (P&#39; ** R) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q v ** R) _ (m R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk46"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, P'</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span>implies P&#39; P</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies (P&#39; ** R) (P ** R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sepconj_imp_l; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">consequence_post</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A) (<span class="nv">IMP</span>: <span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v)) (<span class="nv">m</span>: M P A Q) : M P A Q&#39; :=
  <span class="kr">fun</span> <span class="nv">R</span> =&gt; HST.consequence_post (P ** R) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q v ** R) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q&#39; v ** R) _ (m R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk47"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies (Q v ** R) (Q&#39; v ** R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk48"><span class="nb">apply</span> sepconj_imp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>IMP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, implies (Q v) (Q&#39; v)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v --&gt;&gt; Q&#39; v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IMP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">consequence</span> 
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">P&#39;</span>: PRE) (<span class="nv">Q</span> <span class="nv">Q&#39;</span>: POST A)
               (<span class="nv">IMP1</span>: implies P&#39; P) (<span class="nv">IMP2</span>: <span class="kr">forall</span> <span class="nv">v</span>, implies (Q v) (Q&#39; v)) (<span class="nv">m</span>: M P A Q) : M P&#39; A Q&#39; :=
  consequence_pre _ _ _ IMP1 (consequence_post _ _ _ IMP2 m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">frame</span>
     {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">R</span>: PRE) (<span class="nv">P</span>: PRE) (<span class="nv">Q</span>: POST A) (<span class="nv">m</span>: M P A Q) : M (P ** R) A (<span class="kr">fun</span> <span class="nv">v</span> =&gt; Q v ** R) :=
  <span class="kr">fun</span> <span class="nv">R&#39;</span> =&gt; HST.consequence _ _ _ _ _ _ (m (R ** R&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk49"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R, P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies ((P ** R) ** R&#39;) (P ** R ** R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4a"><span class="nb">rewrite</span> sepconj_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R, P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies (P ** R ** R&#39;) (P ** R ** R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">hnf</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4b"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R, P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies (Q v ** R ** R&#39;) ((Q v ** R) ** R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4c"><span class="nb">rewrite</span> sepconj_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R, P</var><span class="hyp-type"><b>: </b><span>PRE</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M P A Q</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies (Q v ** R ** R&#39;) (Q v ** R ** R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">hnf</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">get</span> (<span class="nv">l</span>: addr) : 
  <span class="kr">forall</span> <span class="nv">v</span>, M (contains l v) Z (<span class="kr">fun</span> <span class="nv">v&#39;</span> =&gt; (v&#39; = v) //\\ contains l v) :=
  <span class="kr">fun</span> <span class="nv">v</span> <span class="nv">R</span> =&gt; HST.consequence_post _ _ _ _ (HST.get l v R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4d"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies ((v0 = v) //\\ contains l v ** R)
  (((v0 = v) //\\ contains l v) ** R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4e"><span class="nb">rewrite</span> lift_pureconj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>assertion</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HST.implies ((v0 = v) //\\ contains l v ** R)
  ((v0 = v) //\\ contains l v ** R)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">hnf</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">set</span> (<span class="nv">l</span>: addr) (<span class="nv">v</span>: Z) :
  M (valid l) unit (<span class="kr">fun</span> <span class="nv">_</span> =&gt; contains l v) :=
  <span class="kr">fun</span> <span class="nv">R</span> =&gt; HST.<span class="nb">set</span> l v R.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">HSep</span>.</span></span></pre><div class="doc">
<a id="lab7"></a><h1 class="section">Dijkstra monads</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab8"></a><h2 class="section">The generic interface</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module Type</span> <span class="nf">DIJKSTRAMONAD</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">PRE</span>: <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">POST</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>), <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TRANSF</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := POST A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">M</span>: <span class="kr">forall</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">W</span>: TRANSF A), <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">RET</span>: <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A), TRANSF A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">ret</span>: <span class="kr">forall</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A), M A (RET v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">BIND</span>:
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B), TRANSF B.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">bind</span>:
    <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B),
    M A W1 -&gt; (<span class="kr">forall</span> (<span class="nv">v</span>: A), M B (W2 v)) -&gt; M B (BIND W1 W2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DIJKSTRAMONAD</span>.</span></span></pre><div class="doc">
<a id="lab9"></a><h2 class="section">The Dijkstra monad of pure computations</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DPure</span> &lt;: DIJKSTRAMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TRANSF</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := POST A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">W</span>: TRANSF A) : <span class="kt">Type</span> :=
  <span class="kr">forall</span> <span class="nv">Q</span>, W Q -&gt; { r: A | Q r}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RET</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : TRANSF A := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; Q v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : M A (RET v) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; exist _ v p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BIND</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B) : TRANSF B :=
  <span class="kr">fun</span> <span class="nv">Q</span> =&gt; W1 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B)
                (<span class="nv">m</span>: M A W1) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M B (W2 v)) : M B (BIND W1 W2) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; <span class="kr">let</span> &#39;(exist _ x q) := m _ p <span class="kr">in</span> f x Q q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DPure</span>.</span></span></pre><div class="doc">
<a id="lab10"></a><h2 class="section">The Dijkstra monad of diverging computations</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DDiv</span> &lt;: DIJKSTRAMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TRANSF</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := POST A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">W</span>: TRANSF A) : <span class="kt">Type</span> := <span class="kr">forall</span> <span class="nv">Q</span>, HDiv.M (W Q) A Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RET</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : TRANSF A := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; Q v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : M A (RET v) := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; HDiv.ret Q v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BIND</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B) : TRANSF B :=
  <span class="kr">fun</span> <span class="nv">Q</span> =&gt; W1 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B)
                (<span class="nv">m</span>: M A W1) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M B (W2 v)) : M B (BIND W1 W2) :=
  <span class="kr">fun</span> <span class="nv">Q</span> =&gt; HDiv.bind (BIND W1 W2 Q) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q) Q (m (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q)) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DDiv</span>.</span></span></pre><div class="doc">
Lifting pure computations to the <span class="inlinecode"><span class="id" title="var">DDiv</span></span> monad. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">DIV_of_PURE</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">W</span>: DPure.TRANSF A) : DDiv.TRANSF A := W.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">div_of_pure</span> {<span class="nv">A</span>: <span class="kt">Type</span>} {<span class="nv">W</span>: DPure.TRANSF A} (<span class="nv">m</span>: DPure.M A W)
  : DDiv.M A (DIV_of_PURE W)
  := <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; <span class="kr">let</span> &#39;(exist _ v q) := m Q p <span class="kr">in</span> (DDiv.ret v Q q).</span></span></pre><div class="doc">
<a id="lab11"></a><h2 class="section">The Dijkstra monad of mutable state</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DST</span> &lt;: DIJKSTRAMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Separation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := heap -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TRANSF</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := POST A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">W</span>: TRANSF A) : <span class="kt">Type</span> := <span class="kr">forall</span> <span class="nv">Q</span>, HST.M (W Q) A Q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RET</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : TRANSF A := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; Q v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : M A (RET v) := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; HST.ret Q v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BIND</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B) : TRANSF B :=
  <span class="kr">fun</span> <span class="nv">Q</span> =&gt; W1 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B)
                (<span class="nv">m</span>: M A W1) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M B (W2 v)) : M B (BIND W1 W2) :=
  <span class="kr">fun</span> <span class="nv">Q</span> =&gt; HST.bind (BIND W1 W2 Q) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q) Q (m (<span class="kr">fun</span> <span class="nv">x</span> =&gt; W2 x Q)) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">GET</span> (<span class="nv">l</span>: addr) : TRANSF Z :=
  <span class="kr">fun</span> <span class="nv">Q</span> (<span class="nv">h</span>: heap) =&gt; <span class="kr">match</span> h l <span class="kr">with</span> Some v =&gt; Q v h | None =&gt; <span class="kt">False</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">get</span> (<span class="nv">l</span>: addr) : M Z (GET l) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; <span class="kr">match</span> h l <span class="kr">with</span> Some v =&gt; (v, h) | None =&gt; _ <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk4f"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>GET l Q h</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk50"><span class="nb">red</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> h l <span class="kr">with</span>
| Some v =&gt; Q v h
| None =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk51"><span class="nb">rewrite</span> &lt;- Heq_anonymous <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Q v h</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>Some v = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q v h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk52"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>GET l Q h</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a_h : Z * heap | Q (fst a_h) (snd a_h)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk53"><span class="nb">exfalso</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>GET l Q h</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk54"><span class="nb">red</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> h l <span class="kr">with</span>
| Some v =&gt; Q v h
| None =&gt; <span class="kt">False</span>
<span class="kr">end</span></span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk55"><span class="nb">rewrite</span> &lt;- Heq_anonymous <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kt">False</span></span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>None = h l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">SET</span> (<span class="nv">l</span>: addr) (<span class="nv">v</span>: Z) : TRANSF unit :=
  <span class="kr">fun</span> <span class="nv">Q</span> (<span class="nv">h</span>: heap) =&gt; h l &lt;&gt; None /\ Q tt (hupdate l v h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">set</span> (<span class="nv">l</span>: addr) (<span class="nv">v</span>: Z) : M unit (SET l v) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; (tt, hupdate l v h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk56"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>addr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST ()</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>SET l v Q h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q () (hupdate l v h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DST</span>.</span></span></pre><div class="doc">
Lifting pure computations to the <span class="inlinecode"><span class="id" title="var">DST</span></span> monad. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ST_of_PURE</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">W</span>: DPure.TRANSF A) : DST.TRANSF A :=
  <span class="kr">fun</span> (<span class="nv">Q</span>: DST.POST A) <span class="nv">h</span> =&gt; W (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Q a h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">st_of_pure</span> {<span class="nv">A</span>: <span class="kt">Type</span>} {<span class="nv">W</span>: DPure.TRANSF A} (<span class="nv">m</span>: DPure.M A W)
  : DST.M A (ST_of_PURE W)
  := <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">h</span> <span class="nv">p</span> =&gt; (m (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Q a h) p, h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk57"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span>DPure.TRANSF A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DPure.M A W</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>DST.POST A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Separation.heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ST_of_PURE W Q h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (` (m (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Q a h) p)) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk58"><span class="nb">destruct</span> m; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span>DPure.TRANSF A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DPure.M A W</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>DST.POST A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Separation.heap</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ST_of_PURE W Q h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q x h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q x h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<a id="lab12"></a><h2 class="section">The Dijkstra monad of exceptions</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameter</span> <span class="nv">exn</span>: <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">DExn</span> &lt;: DIJKSTRAMONAD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">PRE</span> := <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">POST</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := A + exn -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">TRANSF</span> (<span class="nv">A</span>: <span class="kt">Type</span>) := POST A -&gt; PRE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">M</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">W</span>: TRANSF A) : <span class="kt">Type</span> :=
  <span class="kr">forall</span> <span class="nv">Q</span>, W Q -&gt; { r: A + exn | Q r}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RET</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : TRANSF A := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; Q (inl v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ret</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">v</span>: A) : M A (RET v) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; exist _ (inl v) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">BIND</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B) : TRANSF B :=
  <span class="kr">fun</span> <span class="nv">Q</span> =&gt; W1 (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">match</span> x <span class="kr">with</span> inl v =&gt; W2 v Q | inr e =&gt; Q (inr e) <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">bind</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} (<span class="nv">W1</span>: TRANSF A) (<span class="nv">W2</span>: A -&gt; TRANSF B)
                   (<span class="nv">m</span>: M A W1) (<span class="nv">f</span>: <span class="kr">forall</span> (<span class="nv">v</span>: A), M B (W2 v)) : M B (BIND W1 W2) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; <span class="kr">match</span> m _ p <span class="kr">with</span> inl v =&gt; f v Q _ | inr e =&gt; inr e <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk59"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>BIND W1 W2 Q</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inl v =
`
(m
   (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
    <span class="kr">match</span> x <span class="kr">with</span>
    | inl v =&gt; W2 v Q
    | inr e =&gt; Q (inr e)
    <span class="kr">end</span>) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">W2 v Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5a"><span class="nb">red</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inl v =
`
(m
   (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
    <span class="kr">match</span> x <span class="kr">with</span>
    | inl v =&gt; W2 v Q
    | inr e =&gt; Q (inr e)
    <span class="kr">end</span>) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">W2 v Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5b"><span class="nb">destruct</span> m <span class="kr">as</span> [r q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(A + exn)%type</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| inl v =&gt; W2 v Q
| inr e =&gt; Q (inr e)
<span class="kr">end</span></span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inl v =
`
(exist
   (<span class="kr">fun</span> <span class="nv">r</span> : A + exn =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl v =&gt; W2 v Q
    | inr e =&gt; Q (inr e)
    <span class="kr">end</span>) r q)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">W2 v Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5c"><span class="nb">cbn</span> <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(A + exn)%type</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| inl v =&gt; W2 v Q
| inr e =&gt; Q (inr e)
<span class="kr">end</span></span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inl v = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">W2 v Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5d"><span class="nb">subst</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>W2 v Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">W2 v Q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5e"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>BIND W1 W2 Q</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>exn</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inr e =
`
(m
   (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
    <span class="kr">match</span> x <span class="kr">with</span>
    | inl v =&gt; W2 v Q
    | inr e =&gt; Q (inr e)
    <span class="kr">end</span>) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inr e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk5f"><span class="nb">red</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>exn</span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inr e =
`
(m
   (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
    <span class="kr">match</span> x <span class="kr">with</span>
    | inl v =&gt; W2 v Q
    | inr e =&gt; Q (inr e)
    <span class="kr">end</span>) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inr e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk60"><span class="nb">destruct</span> m <span class="kr">as</span> [r q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>exn</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(A + exn)%type</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| inl v =&gt; W2 v Q
| inr e =&gt; Q (inr e)
<span class="kr">end</span></span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inr e =
`
(exist
   (<span class="kr">fun</span> <span class="nv">r</span> : A + exn =&gt;
    <span class="kr">match</span> r <span class="kr">with</span>
    | inl v =&gt; W2 v Q
    | inr e =&gt; Q (inr e)
    <span class="kr">end</span>) r q)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inr e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk61"><span class="nb">cbn</span> <span class="kr">in</span> Heq_anonymous.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>exn</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(A + exn)%type</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> r <span class="kr">with</span>
| inl v =&gt; W2 v Q
| inr e =&gt; Q (inr e)
<span class="kr">end</span></span></span></span><br><span><var>Heq_anonymous</var><span class="hyp-type"><b>: </b><span>inr e = r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inr e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk62"><span class="nb">subst</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W1</var><span class="hyp-type"><b>: </b><span>TRANSF A</span></span></span><br><span><var>W2</var><span class="hyp-type"><b>: </b><span>A -&gt; TRANSF B</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M A W1</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : A, M B (W2 v)</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>POST B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>W1
  (<span class="kr">fun</span> <span class="nv">x</span> : A + exn =&gt;
   <span class="kr">match</span> x <span class="kr">with</span>
   | inl v =&gt; W2 v Q
   | inr e =&gt; Q (inr e)
   <span class="kr">end</span>)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>exn</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q (inr e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inr e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">  
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RAISE</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">e</span>: exn) : TRANSF A := <span class="kr">fun</span> <span class="nv">Q</span> =&gt; Q (inr e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">raise</span> (<span class="nv">A</span>: <span class="kt">Type</span>) (<span class="nv">e</span>: exn) : M A (RAISE A e) :=
  <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; exist _ (inr e) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DExn</span>.</span></span></pre><div class="doc">
Lifting pure computations to the <span class="inlinecode"><span class="id" title="var">DExn</span></span> monad. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">EXN_of_PURE</span> {<span class="nv">A</span>: <span class="kt">Type</span>} (<span class="nv">W</span>: DPure.TRANSF A) : DExn.TRANSF A :=
  <span class="kr">fun</span> (<span class="nv">Q</span>: DExn.POST A) =&gt; W (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Q (inl a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">exn_of_pure</span> {<span class="nv">A</span>: <span class="kt">Type</span>} {<span class="nv">W</span>: DPure.TRANSF A} (<span class="nv">m</span>: DPure.M A W)
  : DExn.M A (EXN_of_PURE W)
  := <span class="kr">fun</span> <span class="nv">Q</span> <span class="nv">p</span> =&gt; inl (proj1_sig (m (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Q (inl a)) p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk63"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span>DPure.TRANSF A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DPure.M A W</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>DExn.POST A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>EXN_of_PURE W Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inl (` (m (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; Q (inl a)) p)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Monads-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="Monads-v-chk64"><span class="nb">destruct</span> m; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>W</var><span class="hyp-type"><b>: </b><span>DPure.TRANSF A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>DPure.M A W</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>DExn.POST A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>EXN_of_PURE W Q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q (inl x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (inl x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>