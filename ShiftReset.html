<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>ShiftReset.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ShiftReset-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="ShiftReset-v-chk0"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ZArith Lia Bool List String Program.Equality.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> FunctionalExtensionality PropExtensionality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> CDF <span class="kn">Require Import</span> Common Sequences Separation2 Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Local Open Scope nat_scope. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> Z_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> list_scope.</span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Syntax</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">expr</span> : <span class="kt">Type</span> :=
  | eint (i:Z)
  | elamb (x:<span class="kn">ident</span>) (e:expr)
  | <span class="nb">evar</span> (x:<span class="kn">ident</span>)
  <span class="c">(* | efree (v:ident) *)</span>
  <span class="c">(* | ebound (i:nat) *)</span>
  <span class="c">(* https://chargueraud.org/research/2009/ln/main.pdf *)</span>
  | eapp (f:<span class="kn">ident</span>) (x:<span class="kn">ident</span>)
  | elet (x:<span class="kn">ident</span>) (e1:expr) (e2:expr)
  | <span class="nb">eassert</span> (x:assertion)
  | eif (x:<span class="kn">ident</span>) (e1:expr) (e2:expr)
  | eshift (e:<span class="kn">ident</span>)
  | ereset (e:expr).</span></span></pre><div class="doc">
<a id="lab2"></a><h1 class="section">Model</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
Values occur at runtime and may not have a corresponding syntax. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">val</span> : <span class="kt">Type</span> :=
  | vloc (i:Z)
  | vint (i:Z)
  | vclos (x:<span class="kn">ident</span>) (e:expr) (s:store val).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Inductive is_val : expr -&gt; Prop :=</span>
<span class="c">  | vint : forall n, is_val (eint n)</span>
<span class="c">  | vlamb : forall x b, is_val (elamb x b). *)</span>

<span class="c">(* Definition to_val (v:expr) : option val :=</span>
<span class="c">  match v with</span>
<span class="c">  | eint i =&gt; Some (vint i)</span>
<span class="c">  | elamb x e =&gt; Some (vlamb x e)</span>
<span class="c">  | elamb x e =&gt; Some (vlamb x e)</span>
<span class="c">  | _ =&gt; None. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">store</span> := store val.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">eresult</span> : <span class="kt">Type</span> :=
  | resshift (ve:expr) (vl:expr)
  | resbot
  | resnorm (v:val).</span></span></pre><div class="doc">
<a id="lab3"></a><h1 class="section">Big-step semantics</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot; &#39;eval[&#39; s &#39;,&#39; h &#39;,&#39; e &#39;]&#39; &#39;=&gt;&#39; &#39;[&#39; s1 &#39;,&#39; h1 &#39;,&#39; r &#39;]&#39; &quot;</span> (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">bigstep</span> : store -&gt; heap -&gt; expr -&gt; store -&gt; heap -&gt; eresult -&gt; <span class="kt">Prop</span> :=

  | eval_int : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">i</span>,
    <span class="kp">eval</span>[ s, h, eint i ]=&gt;[ s, h, resnorm (vint i) ]

  | eval_lamb : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">x</span> <span class="nv">e</span>,
    <span class="kp">eval</span>[ s, h, elamb x e ]=&gt;[ s, h, resnorm (vclos x e s) ]

  | eval_var : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">x</span> <span class="nv">v</span>,
    Some v = s x -&gt;
    <span class="kp">eval</span>[ s, h, <span class="nb">evar</span> x ]=&gt;[ s, h, resnorm v ]

  | eval_app : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">e</span> <span class="nv">v</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">r</span> <span class="nv">sf</span>,
    Some (vclos y e sf) = s f -&gt;
    Some v = s x -&gt;
    <span class="kp">eval</span>[ supdate f (vclos y e sf) (supdate y v sf), h, e ] =&gt; [ s1, h1, r ] -&gt;
    <span class="kp">eval</span>[ s, h, eapp f x ] =&gt; [ s, h1, r ]

  | eval_let : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">v</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">h2</span> <span class="nv">s2</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">r</span>,
    <span class="kp">eval</span>[ s, h, e1 ] =&gt; [ s1, h1, resnorm v ] -&gt;
    <span class="kp">eval</span>[ supdate x v s1, h1, e2 ] =&gt; [ s2, h2, r ] -&gt;
    <span class="kp">eval</span>[ s, h, elet x e1 e2 ] =&gt; [ sremove x s2, h2, r ]

  | eval_ift : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">r</span>,
    Some (vint <span class="mi">0</span>) = s x -&gt;
    <span class="kp">eval</span>[ s, h, e1 ] =&gt; [ s1, h1, r ] -&gt;
    <span class="kp">eval</span>[ s, h, eif x e1 e2 ] =&gt; [ s1, h1, r ]

  | eval_iff : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">r</span>,
    Some (vint <span class="mi">0</span>) &lt;&gt; s x -&gt;
    <span class="kp">eval</span>[ s, h, e2 ] =&gt; [ s1, h1, r ] -&gt;
    <span class="kp">eval</span>[ s, h, eif x e1 e2 ] =&gt; [ s1, h1, r ]

  | eval_shift : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e</span> <span class="nv">b</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">y</span> <span class="nv">sf</span>,
    Some (vclos x e sf) = s b -&gt;
    <span class="kp">eval</span>[ s, h, eshift b ] =&gt; [ s, h, resshift (elamb x e) (elamb y (<span class="nb">evar</span> y)) ]

  | eval_letshift : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">r</span> <span class="nv">el</span> <span class="nv">vl</span> <span class="nv">z</span> <span class="nv">f</span>,
    <span class="kp">eval</span>[ s, h, e1 ] =&gt; [ s1, h1, resshift el vl ] -&gt;
    r = resshift el (elamb z (elet z (elet f vl (eapp f z)) e2)) -&gt;
    <span class="kp">eval</span>[ s, h, elet x e1 e2 ] =&gt; [ s1, h1, r ]

  | eval_resetshift : <span class="kr">forall</span> <span class="nv">e</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">s2</span> <span class="nv">h2</span> <span class="nv">r</span> <span class="nv">el</span> <span class="nv">vl</span> <span class="nv">f</span> <span class="nv">x</span>,
    <span class="kp">eval</span>[ s, h, e ] =&gt; [ s1, h1, resshift el vl ] -&gt;
    <span class="kp">eval</span>[ s, h, ereset (elet f el (elet x vl (eapp f x))) ] =&gt; [ s2, h2, r ] -&gt;
    <span class="kp">eval</span>[ s, h, ereset e ] =&gt; [ s2, h2, r ]

  | eval_resetval : <span class="kr">forall</span> <span class="nv">e</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">v</span>,
    <span class="kp">eval</span>[ s, h, e ] =&gt; [ s1, h1, resnorm v ] -&gt;
    <span class="kp">eval</span>[ s, h, ereset e ] =&gt; [ s1, h1, resnorm v ]

<span class="kn">where</span> <span class="s2">&quot; &#39;eval[&#39; s &#39;,&#39; h &#39;,&#39; e &#39;]&#39; &#39;=&gt;&#39; &#39;[&#39; s1 &#39;,&#39; h1 &#39;,&#39; r &#39;]&#39; &quot;</span> := (bigstep s h e s1 h1 r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ProgramExamples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Example ex_ref :</span>
<span class="c">    eval[ sempty, hempty, plet &quot;x&quot; (pconst 1) (pref &quot;x&quot;) ]=&gt;[ sempty, hupdate 2 1 hempty, enorm 2 ].</span>
<span class="c">  Proof.</span>
<span class="c">    apply eval_plet with (v:=1) (s1:=sempty) (s2:=supdate &quot;x&quot; 1 sempty) (h1:=hempty).</span>
<span class="c">    apply eval_pconst.</span>
<span class="c">    apply eval_pref.</span>
<span class="c">    constructor.</span>
<span class="c">  Qed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ProgramExamples</span>.</span></span></pre></article></body></html>