<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Flow.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk0"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ZArith Lia Bool List String Program.Equality.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> CDF <span class="kn">Require Import</span> Common Sequences Separation2 Tactics HeapTactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* From Coq Require Import ssreflect ssrfun ssrbool. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> string_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Local Open Scope nat_scope. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> Z_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1"><span class="kn">Theorem</span> <span class="nf">ident_neq_sym</span> : <span class="kr">forall</span> (<span class="nv">n</span>:ident) <span class="nv">m</span>, n &lt;&gt; m -&gt; m &lt;&gt; n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : <span class="kn">ident</span>, n &lt;&gt; m -&gt; m &lt;&gt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : <span class="kn">ident</span>, n &lt;&gt; m -&gt; m &lt;&gt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n m H1 H2; <span class="nb">symmetry in</span> H2; false_hyp H2 H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">val</span> := Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">expr</span> : <span class="kt">Type</span> :=
  | pvar (x: <span class="kn">ident</span>)
  | pconst (n: val)
  | plet (x: <span class="kn">ident</span>) (e1: expr) (e2: expr)
  <span class="c">(* | pref (x: ident) *)</span>
  <span class="c">(* | pderef (x: ident) *)</span>
  <span class="c">(* | passign (x1: ident) (x2: ident) *)</span>
  | pif (x: <span class="kn">ident</span>) (e1: expr) (e2: expr)
  | pcall (x: <span class="kn">ident</span>) (a: <span class="kn">ident</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">eresult</span> : <span class="kt">Type</span> :=
  | enorm : val -&gt; eresult.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Reserved Notation</span> <span class="s2">&quot; &#39;eval[&#39; s &#39;,&#39; h &#39;,&#39; e &#39;]&#39; &#39;=&gt;&#39; &#39;[&#39; s1 &#39;,&#39; h1 &#39;,&#39; r &#39;]&#39; &quot;</span> (<span class="kn">at level</span> <span class="mi">50</span>, <span class="kn">left associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">store</span> := store Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">bigstep</span> : store -&gt; heap -&gt; expr -&gt; store -&gt; heap -&gt; eresult -&gt; <span class="kt">Prop</span> :=
  | eval_pvar : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">x</span> <span class="nv">v</span>,
    Some v = s x -&gt;
    <span class="kp">eval</span>[ s, h, pvar x ]=&gt;[ s, h, enorm v]
  | eval_pconst : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">x</span>,
    <span class="kp">eval</span>[ s, h, pconst x ] =&gt; [ s, h, enorm x]
  | eval_plet : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">v</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">h2</span> <span class="nv">s2</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">r</span>,
    <span class="kp">eval</span>[ s, h, e1 ] =&gt; [ s1, h1, enorm v] -&gt;
    <span class="kp">eval</span>[ supdate x v s1, h1, e2 ] =&gt; [ s2, h2, r] -&gt;
    <span class="kp">eval</span>[ s, h, plet x e1 e2 ] =&gt; [ s2, h2, r ]
  <span class="c">(* | eval_pref : forall x s (h:heap) l,</span>
<span class="c">    h l = None -&gt;</span>
<span class="c">    eval[ s, h, pref x ] =&gt; [ s, hupdate l (s x) h, enorm l]</span>
<span class="c">  | eval_deref : forall x s (h:heap) v,</span>
<span class="c">    h (s x) = Some v -&gt;</span>
<span class="c">    eval[ s, h, pderef x ] =&gt; [ s, h, enorm v]</span>
<span class="c">  | eval_assign : forall x1 x2 s h,</span>
<span class="c">    eval[ s, h, passign x1 x2 ] =&gt; [ s, hupdate (s x1) (s x2) h, enorm 0] *)</span>

  <span class="kn">where</span> <span class="s2">&quot; &#39;eval[&#39; s &#39;,&#39; h &#39;,&#39; e &#39;]&#39; &#39;=&gt;&#39; &#39;[&#39; s1 &#39;,&#39; h1 &#39;,&#39; r &#39;]&#39; &quot;</span> := (bigstep s h e s1 h1 r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">ProgramExamples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Example ex_ref :</span>
<span class="c">    eval[ sempty, hempty, plet &quot;x&quot; (pconst 1) (pref &quot;x&quot;) ]=&gt;[ sempty, hupdate 2 1 hempty, enorm 2 ].</span>
<span class="c">  Proof.</span>
<span class="c">    apply eval_plet with (v:=1) (s1:=sempty) (s2:=supdate &quot;x&quot; 1 sempty) (h1:=hempty).</span>
<span class="c">    apply eval_pconst.</span>
<span class="c">    apply eval_pref.</span>
<span class="c">    constructor.</span>
<span class="c">  Qed. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ProgramExamples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">precond</span> := assertion.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">postcond</span> := Z -&gt; assertion.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">result</span> : <span class="kt">Type</span> :=
  | norm : Z -&gt; result.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compatible</span> <span class="nv">r1</span> <span class="nv">r2</span> :=
    <span class="kr">match</span> (r1, r2) <span class="kr">with</span>
    | (norm r3, enorm r4) =&gt; r3 = r4
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">flow</span> : <span class="kt">Type</span> :=
  | req : precond -&gt; flow
  | ens : postcond -&gt; flow
  | seq : flow -&gt; flow -&gt; flow
  <span class="c">(* | fexists : (Z -&gt; flow) -&gt; flow. *)</span>
  | fexists : <span class="kn">ident</span> -&gt; flow -&gt; flow.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition flow := Z -&gt; stages. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">empty</span> := ens (<span class="kr">fun</span> <span class="nv">r</span> =&gt; pure <span class="kt">True</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;;;&quot;</span> := seq (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">replace_ret</span> <span class="nv">x</span> <span class="nv">f</span> :=
  <span class="kr">match</span> f <span class="kr">with</span>
  | ens q =&gt; ens (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">s</span> <span class="nv">h</span> =&gt; <span class="kr">exists</span> <span class="nv">v</span>, s x = Some v /\ q v s h)
  | req _ =&gt; f
  | seq a b =&gt; seq a (replace_ret x b)
  | fexists i f =&gt; fexists i (replace_ret x f)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">compose</span> (<span class="nv">x</span>:ident) (<span class="nv">f1</span> <span class="nv">f2</span>:flow) : flow :=
  fexists x (replace_ret x f1 ;; f2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">fresh_in_flow</span> (<span class="nv">x</span>:ident) (<span class="nv">f</span>:flow) :=
  <span class="kr">match</span> f <span class="kr">with</span>
  | ens q =&gt; <span class="kt">True</span>
  | req _ =&gt; <span class="kt">True</span>
  | seq a b =&gt; fresh_in_flow x a /\ fresh_in_flow x b
  | fexists i f =&gt; x &lt;&gt; i /\ fresh_in_flow x f
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk3"><span class="kn">Lemma</span> <span class="nf">fresh_replace</span> : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">i</span>,
  fresh_in_flow i (replace_ret x f) -&gt;
  fresh_in_flow i f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">x</span> <span class="nv">i</span> : ident),
fresh_in_flow i (replace_ret x f) -&gt; fresh_in_flow i f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">x</span> <span class="nv">i</span> : ident),
fresh_in_flow i (replace_ret x f) -&gt; fresh_in_flow i f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5"><span class="nb">induction</span> f; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">intuition</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>,
fresh_in_flow i (replace_ret x f1) -&gt;
fresh_in_flow i f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>,
fresh_in_flow i (replace_ret x f2) -&gt;
fresh_in_flow i f2</span></span></span><br><span><var>x, i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i f1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow i f2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>,
fresh_in_flow i (replace_ret x f) -&gt;
fresh_in_flow i f</span></span></span><br><span><var>x, i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>i0 = i -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i0 (replace_ret x f)</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk6"><hr></label><div class="goal-conclusion">fresh_in_flow i0 f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>,
fresh_in_flow i (replace_ret x f1) -&gt;
fresh_in_flow i f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>,
fresh_in_flow i (replace_ret x f2) -&gt;
fresh_in_flow i f2</span></span></span><br><span><var>x, i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i f1</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow i f2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> <span class="nb">apply</span> IHf2 <span class="kr">with</span> (x:=x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>, fresh_in_flow i (replace_ret x f) -&gt; fresh_in_flow i f</span></span></span><br><span><var>x, i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>i0 = i -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i0 (replace_ret x f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow i0 f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk9"><span class="nb">apply</span> IHf <span class="kr">with</span> (x:=x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">i</span> : <span class="kn">ident</span>, fresh_in_flow i (replace_ret x f) -&gt; fresh_in_flow i f</span></span></span><br><span><var>x, i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>i0 = i -&gt; <span class="kt">False</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i0 (replace_ret x f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow i0 (replace_ret x f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Reserved Notation &quot; &#39;sem[&#39; t &#39;,&#39; s &#39;,&#39; h &#39;]=&gt;[&#39; t1 &#39;,&#39; s1 &#39;,&#39; h1 &#39;,&#39; r &#39;]&#39; &#39;|=&#39; f &quot; (at level 50, left associativity). *)</span>

<span class="c">(* axiomatization of semantics for staged formulae *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">satisfies</span> : store -&gt; heap -&gt; store -&gt; heap -&gt; result -&gt; flow -&gt; <span class="kt">Prop</span> :=

  | sat_req p s1 h1 s2 h2 r h3
    (Hsu: s1 = s2)
    <span class="c">(* h3 is the piece taken out satisfying p *)</span>
    (Hex: h1 = hunion h2 h3)
    (Hd: hdisjoint h2 h3)
    (Hp: p s1 h3) :
    satisfies s1 h1 s2 h2 (norm r) (req p)

  | sat_ens q s1 h1 s2 h2 h3 v
    (Hsu:s1 = s2)
    <span class="c">(* forall v, r = norm v -&gt; *)</span>
    <span class="c">(* (Hr: r = norm v) *)</span>
    <span class="c">(* h3 is the piece satisfying q that is addded to h1 *)</span>
    (Hh: h2 = hunion h1 h3)
    (Hd: hdisjoint h1 h3)
    (Hq: q v s1 h3) :
    satisfies s1 h1 s2 h2 (norm v) (ens q)

  | sat_seq f1 f2 s1 h1 s2 h2 r s3 h3 r1
    (Hs1: satisfies s1 h1 s3 h3 r1 f1)
    (Hs2: satisfies s3 h3 s2 h2 r f2) :
    satisfies s1 h1 s2 h2 r (seq f1 f2)

  | sat_ex
    x f s1 h1 s2 h2 r
    (Hnotin: s1 x = None)
    (Hfresh: fresh_in_flow x f)
    (Hex: <span class="kr">exists</span> <span class="nv">v</span>, satisfies (supdate x v s1) h1 s2 h2 r f) :
    satisfies s1 h1 s2 h2 r (fexists x f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* where &quot; &#39;sem[&#39; t &#39;,&#39; s &#39;,&#39; h &#39;]=&gt;[&#39; t1 &#39;,&#39; s1 &#39;,&#39; h1 &#39;,&#39; r &#39;]&#39; &#39;|=&#39; f &quot; := (satisfies t s h t1 s1 h1 r f) *)</span></span></pre><div class="doc">
Result can be anything if unconstrained 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka"><span class="kn">Lemma</span> <span class="nf">unconstrained_res</span> : <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">h</span> <span class="nv">v</span>,
  satisfies s h s h (norm v) empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> : store) (<span class="nv">h</span> : heap) (<span class="nv">v</span> : Z),
satisfies s h s h (norm v) empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> : store) (<span class="nv">h</span> : heap) (<span class="nv">v</span> : Z),
satisfies s h s h (norm v) empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm v) empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkd"><span class="nb">apply</span> sat_ens <span class="kr">with</span> (h3:=hempty); heap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pure <span class="kt">True</span> s hempty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chke"><span class="nb">unfold</span> pure.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span> /\ hempty = hempty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
replace_ret removes the result value and constrains the given variable 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkf"><span class="kn">Example</span> <span class="nf">e_replace_ret</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">h</span>,
  satisfies s h s h (norm <span class="mi">2</span>) (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> =&gt; pure (r = <span class="mi">1</span>)))) &lt;-&gt;
    satisfies s h s h (norm <span class="mi">2</span>) (ens (<span class="kr">fun</span> <span class="nv">r</span> <span class="nv">s</span> <span class="nv">h</span> =&gt; s x = Some <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">s</span> : store) (<span class="nv">h</span> : heap),
satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)))) &lt;-&gt;
satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s0</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s0 x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">s</span> : store) (<span class="nv">h</span> : heap),
satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)))) &lt;-&gt;
satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s0</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s0 x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk11"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)))) -&gt;
satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk12"><hr></label><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>)) -&gt;
satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)))) -&gt;
satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk14"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk15"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
      =&gt;
      <span class="kr">exists</span> <span class="nv">v</span> : Z,
        s x = Some v /\ pure (v = <span class="mi">1</span>) s h))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk16">inv H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ pure (v = <span class="mi">1</span>) s h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk17">destr_all.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>s x = Some H</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>pure (H = <span class="mi">1</span>) s h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk18"><span class="nb">unfold</span> pure <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>s x = Some H</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>H = <span class="mi">1</span> /\ h3 = hempty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk19">destr H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>s x = Some H</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>H = <span class="mi">1</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>h3 = hempty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1a"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h hempty</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h hempty</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>s x = Some <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sat_ens <span class="kr">with</span> (h3:=hempty); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap) =&gt;
      s x = Some <span class="mi">1</span>)) -&gt;
satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap)
      =&gt; s x = Some <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">_</span> : heap)
      =&gt; s x = Some <span class="mi">1</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
      <span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ pure (v = <span class="mi">1</span>) s h))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1e">inv H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>s x = Some <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s h s h (norm <span class="mi">2</span>)
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
      <span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ pure (v = <span class="mi">1</span>) s h))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk1f"><span class="nb">apply</span> sat_ens <span class="kr">with</span> (h3:=hempty); heap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>s x = Some <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ pure (v = <span class="mi">1</span>) s hempty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk20"><span class="kr">exists</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hsu</var><span class="hyp-type"><b>: </b><span>s = s</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h = hunion h h3</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>s x = Some <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s x = Some <span class="mi">1</span> /\ pure (<span class="mi">1</span> = <span class="mi">1</span>) s hempty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> <span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">SemanticsExamples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* ex z; req x-&gt;z; ens[r] x-&gt;1/\r=1 *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">f3</span> : flow :=
    fexists <span class="s2">&quot;z&quot;</span> (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>) ;; ens (<span class="kr">fun</span> <span class="nv">r</span> =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk21"><span class="kn">Example</span> <span class="nf">ex_sem_f3</span>:
    satisfies (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
      (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty)) (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>) f3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>) f3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>) f3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk23"><span class="nb">unfold</span> f3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
  (fexists <span class="s2">&quot;z&quot;</span>
     (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
      ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk24"><span class="nb">apply</span> sat_ex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty <span class="s2">&quot;z&quot;</span> = None</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow <span class="s2">&quot;z&quot;</span>
  (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
   ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z,
  satisfies (supdate <span class="s2">&quot;z&quot;</span> v (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
    (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
    (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
     ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk25">heap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow <span class="s2">&quot;z&quot;</span>
  (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
   ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z,
  satisfies (supdate <span class="s2">&quot;z&quot;</span> v (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
    (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
    (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
     ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk26"><span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z,
  satisfies (supdate <span class="s2">&quot;z&quot;</span> v (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
    (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
    (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
     ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk27"><span class="kr">exists</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
  (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>);;
   ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk28"><span class="nb">apply</span> sat_seq <span class="kr">with</span> (s3:=supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty)) (h3:=hempty) (r1:=norm <span class="mi">5</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty)) hempty
  (norm <span class="mi">5</span>) (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  hempty (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
  (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty)) hempty
  (norm <span class="mi">5</span>) (req (pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2a"><span class="nb">apply</span> sat_req <span class="kr">with</span> (h3:=hupdate <span class="mi">2</span> <span class="mi">3</span> hempty).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) =
supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">hupdate <span class="mi">2</span> <span class="mi">3</span> hempty =
hunion hempty (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">hdisjoint hempty (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2b"><span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">hupdate <span class="mi">2</span> <span class="mi">3</span> hempty =
hunion hempty (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">hdisjoint hempty (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2c">heap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">hdisjoint hempty (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2d">heap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pts <span class="s2">&quot;x&quot;</span> <span class="s2">&quot;z&quot;</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2e"><span class="nb">unfold</span> pts.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> <span class="nv">w</span> : Z,
  Some v = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;x&quot;</span> /\
  Some w = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;z&quot;</span> /\
  contains v w (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk2f"><span class="kr">exists</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">w</span> : Z,
  Some <span class="mi">2</span> = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;x&quot;</span> /\
  Some w = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;z&quot;</span> /\
  contains <span class="mi">2</span> w (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk30"><span class="kr">exists</span> <span class="mi">3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Some <span class="mi">2</span> = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;x&quot;</span> /\
Some <span class="mi">3</span> = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;z&quot;</span> /\
contains <span class="mi">2</span> <span class="mi">3</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">3</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> <span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  hempty (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty) (norm <span class="mi">1</span>)
  (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; (r = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk32"><span class="nb">apply</span> sat_ens <span class="kr">with</span> (h3:=hupdate <span class="mi">2</span> <span class="mi">1</span> hempty); heap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="mi">1</span> = <span class="mi">1</span>) //\\ ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span>)
  (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* rewrite supdate_dupe. *)</span>
      <span class="c">(* reflexivity. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk33"><span class="nb">unfold</span> pureconj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span> /\
ptsval <span class="s2">&quot;x&quot;</span> <span class="mi">1</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk34"><span class="nb">unfold</span> ptsval.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span> /\
(<span class="kr">exists</span> <span class="nv">w</span> : Z,
   Some w = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;x&quot;</span> /\
   contains w <span class="mi">1</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
     (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk35"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">w</span> : Z,
  Some w = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;x&quot;</span> /\
  contains w <span class="mi">1</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
    (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk36"><span class="kr">exists</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Some <span class="mi">2</span> = supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty) <span class="s2">&quot;x&quot;</span> /\
contains <span class="mi">2</span> <span class="mi">1</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk37"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">contains <span class="mi">2</span> <span class="mi">1</span> (supdate <span class="s2">&quot;z&quot;</span> <span class="mi">3</span> (supdate <span class="s2">&quot;x&quot;</span> <span class="mi">2</span> sempty))
  (hupdate <span class="mi">2</span> <span class="mi">1</span> hempty)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk38"><span class="nb">unfold</span> contains.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">hupdate <span class="mi">2</span> <span class="mi">1</span> hempty = hupdate <span class="mi">2</span> <span class="mi">1</span> hempty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">heap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SemanticsExamples</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* forward rules say how to produce a staged formula from a program *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">forward</span> : expr -&gt; flow -&gt; <span class="kt">Prop</span> :=
  | fw_const: <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">p</span>,
    p = (ens (<span class="kr">fun</span> <span class="nv">res</span> =&gt; (res = n) //\\ emp)) -&gt;
    forward (pconst n) p

  | fw_var: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">p</span>,
    p = (ens (<span class="kr">fun</span> <span class="nv">res</span> <span class="nv">s</span> <span class="nv">h</span> =&gt; <span class="kr">exists</span> <span class="nv">v</span>, s x = Some v /\ res = v /\ emp s h)) -&gt;
    forward (pvar x) p

  <span class="c">(* | fw_deref: forall x y,</span>
<span class="c">    forward (pderef x) (fexists y (req (pts x y);;</span>
<span class="c">      ens (fun res s h =&gt; ((res = s y) //\\ pts x y) s h)))</span>

<span class="c">  | fw_ref: forall x y,</span>
<span class="c">    (* forward (pref x) (fexists (fun y =&gt; ens (fun r s h =&gt; contains y (s x) s h))) *)</span>
<span class="c">    forward (pref x) (fexists y (ens (fun r s h =&gt; (r = s y) /\ (pts y x s h)))) *)</span>

  | fw_let: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="nv">f1</span> <span class="nv">f2</span>,
    forward e1 f1 -&gt;
    forward e2 f2 -&gt;
    <span class="c">(* replace_ret x f1 = f3 -&gt; *)</span>
    <span class="c">(* f1 ;; ens (fun _ =&gt; ) = f3 -&gt; *)</span>
    <span class="c">(* forward (plet x e1 e2) (fexists x (f3 ;; f2)) *)</span>
    forward (plet x e1 e2) (compose x f1 f2)

  <span class="c">(* | fw_get: forall l v, </span>
<span class="c">    forward (GET l)</span>
<span class="c">      (req (contains l v) ;;</span>
<span class="c">      (ens (fun r =&gt; (r = v) //\\ contains l v))) *)</span>
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk39"><span class="kn">Example</span> <span class="nf">e_fw_let</span> : <span class="kr">forall</span> <span class="nv">x</span>,
  forward (plet x (pconst <span class="mi">1</span>) (pvar x)) (fexists x (
    replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> =&gt; pure (r = <span class="mi">1</span>))) ;;
    ens (<span class="kr">fun</span> <span class="nv">res</span> <span class="nv">s</span> <span class="nv">h</span> =&gt; <span class="kr">exists</span> <span class="nv">v</span>, Some v = s x /\ res = v /\ emp s h)
    )).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : <span class="kn">ident</span>,
forward (plet x (pconst <span class="mi">1</span>) (pvar x))
  (fexists x
     (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)));;
      ens
        (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
         =&gt;
         <span class="kr">exists</span> <span class="nv">v</span> : Z,
           Some v = s x /\ res = v /\ emp s h)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : <span class="kn">ident</span>,
forward (plet x (pconst <span class="mi">1</span>) (pvar x))
  (fexists x
     (replace_ret x (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)));;
      ens
        (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
         =&gt;
         <span class="kr">exists</span> <span class="nv">v</span> : Z,
           Some v = s x /\ res = v /\ emp s h)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk3b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : <span class="kn">ident</span>,
forward (plet x (pconst <span class="mi">1</span>) (pvar x))
  (fexists x
     (ens
        (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
         =&gt;
         <span class="kr">exists</span> <span class="nv">v</span> : Z,
           s x = Some v /\ pure (v = <span class="mi">1</span>) s h);;
      ens
        (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
         =&gt;
         <span class="kr">exists</span> <span class="nv">v</span> : Z,
           Some v = s x /\ res = v /\ emp s h)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk3c"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forward (plet x (pconst <span class="mi">1</span>) (pvar x))
  (fexists x
     (ens
        (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
         =&gt;
         <span class="kr">exists</span> <span class="nv">v</span> : Z,
           s x = Some v /\ pure (v = <span class="mi">1</span>) s h);;
      ens
        (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
         =&gt;
         <span class="kr">exists</span> <span class="nv">v</span> : Z,
           Some v = s x /\ res = v /\ emp s h)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk3d"><span class="nb">apply</span> fw_let <span class="kr">with</span> (f1 := (ens (<span class="kr">fun</span> <span class="nv">r</span> =&gt; pure (r = <span class="mi">1</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forward (pconst <span class="mi">1</span>) (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><label class="goal-separator" for="Flow-v-chk3e"><hr></label><div class="goal-conclusion">forward (pvar x)
  (ens
     (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
      <span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ res = v /\ emp s h))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forward (pconst <span class="mi">1</span>) (ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk40"><span class="nb">eapply</span> fw_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ens (<span class="kr">fun</span> <span class="nv">r</span> : Z =&gt; pure (r = <span class="mi">1</span>)) =
ens (<span class="kr">fun</span> <span class="nv">res</span> : Z =&gt; (res = <span class="mi">1</span>) //\\ emp)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forward (pvar x)
  (ens
     (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
      <span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ res = v /\ emp s h))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk42"><span class="nb">apply</span> fw_var.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ens
  (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
   <span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ res = v /\ emp s h) =
ens
  (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
   <span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ res = v /\ emp s h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* trivial from here, but we have to go through this whole song and dance *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk43"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
 <span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ res = v /\ emp s h) =
(<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap) =&gt;
 <span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ res = v /\ emp s h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk44">post_ext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ r = v /\ emp s h) &lt;-&gt;
(<span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk45"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ r = v /\ emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk46"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ r = v /\ emp s h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk47">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ r = v /\ emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk48">destr H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some H0 = s x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>r = H0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk49"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some H0 = s x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>r = H0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4a"><span class="kr">exists</span> <span class="nv">H0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some H0 = s x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>r = H0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s x = Some H0 /\ r = H0 /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ r = v /\ emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ r = v /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4c">destr H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>s x = Some H0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>r = H0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v</span> : Z, Some v = s x /\ r = v /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4d"><span class="kr">exists</span> <span class="nv">H0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>s x = Some H0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>r = H0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>emp s h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some H0 = s x /\ r = H0 /\ emp s h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
The semantics only grows the store. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4e"><span class="kn">Definition</span> <span class="nf">satisfies_monotonic</span> : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">s2</span> <span class="nv">h2</span> <span class="nv">r</span>,
  satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap)
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap)
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk50"><span class="nb">induction</span> f; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>precond</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (req p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (ens p)</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk51"><hr></label><div class="goal-conclusion">substore s1 s2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Flow-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f1 -&gt; substore s1 s2</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f2 -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (f1;; f2)</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk52"><hr></label><div class="goal-conclusion">substore s1 s2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Flow-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (fexists i f)</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk53"><hr></label><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>precond</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (req p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk55">inv H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>precond</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h2 h4</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>p s2 h4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (ens p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk57">inv H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h4</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>p v s2 h4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f1 -&gt; substore s1 s2</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f2 -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (f1;; f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk59">inv H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f1 -&gt; substore s1 s2</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f2 -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r f2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5a"><span class="nb">specialize</span> (IHf1 _ _ _ _ _ Hs1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s1, s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f2 -&gt; substore s1 s2</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r f2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5b"><span class="nb">specialize</span> (IHf2 _ _ _ _ _ Hs2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s1, s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>substore s4 s2</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r f2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> substore_trans <span class="kr">with</span> (s2 := s4); <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (fexists i f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5d">inv H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i f</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z,
  satisfies (supdate i v s1) h1 s2 h2 r f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5e"><span class="nb">destruct</span> Hex <span class="kr">as</span> [v Hsat].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s1</span> : store) (<span class="nv">h1</span> : heap) 
  (<span class="nv">s2</span> : store) (<span class="nv">h2</span> : heap) 
  (<span class="nv">r</span> : result),
satisfies s1 h1 s2 h2 r f -&gt; substore s1 s2</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i f</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v s1) h1 s2 h2 r f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk5f"><span class="nb">specialize</span> (IHf _ _ _ _ _ Hsat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>substore (supdate i v s1) s2</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i f</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v s1) h1 s2 h2 r f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk60"><span class="nb">specialize</span> (substore_reduce_left _ _ _ _ _ Hnotin IHf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>substore (supdate i v s1) s2</span></span></span><br><span><var>h1, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i f</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v s1) h1 s2 h2 r f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s1 s2 -&gt; substore s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk61"><span class="kn">Lemma</span> <span class="nf">satisfies_replace_ret</span> : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">v</span> <span class="nv">s1</span> <span class="nv">h1</span> <span class="nv">s2</span> <span class="nv">h2</span> <span class="nv">r</span>,
  fresh_in_flow x f -&gt;
  s1 x = Some v -&gt;
  satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
  satisfies s1 h1 s2 h2 (norm v) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store)
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store)
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk63"><span class="nb">induction</span> f; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>precond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (req p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (req p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
      =&gt; <span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ p v s h))</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk64"><hr></label><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (ens p)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Flow-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f2 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f2) -&gt;
satisfies s1 h1 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 /\ fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (f1;; replace_ret x f2)</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk65"><hr></label><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Flow-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i /\ fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r
  (fexists i (replace_ret x f))</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk66"><hr></label><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>precond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (req p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (req p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk68">inv H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>precond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s2 x = Some v</span></span></span><br><span><var>r0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h2 h4</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>p s2 h4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s2 (hunion h2 h4) s2 h2 (norm v) (req p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sat_req <span class="kr">with</span> (h3 := h4); ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r
  (ens
     (<span class="kr">fun</span> (<span class="nv">_</span> : Z) (<span class="nv">s</span> : Common.store Z) (<span class="nv">h</span> : heap)
      =&gt; <span class="kr">exists</span> <span class="nv">v</span> : Z, s x = Some v /\ p v s h))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (ens p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk6a">inv H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s2 x = Some v</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h4</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z, s2 x = Some v /\ p v s2 h4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s2 h1 s2 (hunion h1 h4) (norm v) (ens p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk6b"><span class="nb">destruct</span> Hq <span class="kr">as</span> [v1 [H3 H2]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s2 x = Some v</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h4</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>s2 x = Some v1</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p v1 s2 h4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s2 h1 s2 (hunion h1 h4) (norm v) (ens p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk6c"><span class="nb">rewrite</span> H3 <span class="kr">in</span> H0; inj H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>postcond</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kt">True</span></span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint h1 h4</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>p v s2 h4</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>s2 x = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s2 h1 s2 (hunion h1 h4) (norm v) (ens p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sat_ens <span class="kr">with</span> (h3 := h4); ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk6d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f2 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f2) -&gt;
satisfies s1 h1 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 /\ fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r (f1;; replace_ret x f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk6e">inv H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f2 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f2) -&gt;
satisfies s1 h1 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 /\ fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r (replace_ret x f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk6f"><span class="nb">pose proof</span> (satisfies_monotonic _ _ _ _ _ _ Hs1) <span class="kr">as</span> Hmono1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f2 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f2) -&gt;
satisfies s1 h1 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 /\ fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r (replace_ret x f2)</span></span></span><br><span><var>Hmono1</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk70"><span class="nb">pose proof</span> (substore_mem _ s1 s4 v x Hmono1 H0) <span class="kr">as</span> Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f2 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f2) -&gt;
satisfies s1 h1 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 /\ fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r (replace_ret x f2)</span></span></span><br><span><var>Hmono1</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>s4 x = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk71"><span class="nb">destruct</span> H <span class="kr">as</span> [Hf1 Hf2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f2 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f2) -&gt;
satisfies s1 h1 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r (replace_ret x f2)</span></span></span><br><span><var>Hmono1</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>s4 x = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk72"><span class="nb">specialize</span> (IHf2 x v s4 h4 s2 h2 r Hf2 Hs Hs2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f1 -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f1) -&gt;
satisfies s1 h1 s2 h2 (norm v) f1</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 (norm v) f2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s4 h4 r1 f1</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 s2 h2 r (replace_ret x f2)</span></span></span><br><span><var>Hmono1</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>s4 x = Some v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (f1;; f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sat_seq <span class="kr">with</span> (s3:=s4) (h3:=h4) (r1:=r1); ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk73">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i /\ fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>satisfies s1 h1 s2 h2 r
  (fexists i (replace_ret x f))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk74">inv H1; <span class="nb">destruct</span> Hex <span class="kr">as</span> [v0 Hsat].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i /\ fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk75"><span class="nb">destruct</span> H <span class="kr">as</span> [Hneq Hf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk76"><span class="nb">pose proof</span> (ident_neq_sym _ _ Hneq) <span class="kr">as</span> Hneq1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk77"><span class="nb">pose proof</span> (supdate_other _ s1 i v0 x Hneq1) <span class="kr">as</span> He.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk78"><span class="nb">rewrite</span> &lt;- He <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : ident) (<span class="nv">v</span> : Z)
  (<span class="nv">s1</span> : ident -&gt; option Z) 
  (<span class="nv">h1</span> : heap) (<span class="nv">s2</span> : store) 
  (<span class="nv">h2</span> : heap) (<span class="nv">r</span> : result),
fresh_in_flow x f -&gt;
s1 x = Some v -&gt;
satisfies s1 h1 s2 h2 r (replace_ret x f) -&gt;
satisfies s1 h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk79"><span class="nb">specialize</span> (IHf x v (supdate i v0 s1) h1 s2 h2 r Hf H0 Hsat).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies s1 h1 s2 h2 (norm v) (fexists i f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk7a"><span class="nb">apply</span> sat_ex; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow i f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk7b"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v0</span> : Z,
  satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk7c"><span class="nb">apply</span> fresh_replace <span class="kr">with</span> (x:=x); <span class="bp">easy</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">v0</span> : Z,
  satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk7d"><span class="kr">exists</span> <span class="nv">v0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; i</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = Some v</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>s1 i = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow i (replace_ret x f)</span></span></span><br><span><var>Hsat</var><span class="hyp-type"><b>: </b><span>satisfies (supdate i v0 s1) h1 s2 h2 r
  (replace_ret x f)</span></span></span><br><span><var>Hneq1</var><span class="hyp-type"><b>: </b><span>i &lt;&gt; x</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>supdate i v0 s1 x = s1 x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">satisfies (supdate i v0 s1) h1 s2 h2 (norm v) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk7e"><span class="kn">Theorem</span> <span class="nf">soundness</span> :
  <span class="kr">forall</span> <span class="nv">se1</span> <span class="nv">he1</span> <span class="nv">e</span> <span class="nv">se2</span> <span class="nv">he2</span> <span class="nv">re</span> (**) <span class="nv">f</span> <span class="nv">ss1</span> <span class="nv">hs1</span> <span class="nv">ss2</span> <span class="nv">hs2</span> <span class="nv">rs</span>,
    bigstep se1 he1 e se2 he2 re -&gt;
    substore se1 ss1 -&gt;
    <span class="c">(* he1 = hs1 -&gt; *)</span>
    forward e f -&gt;
    satisfies ss1 hs1 ss2 hs2 rs f -&gt;
    substore se2 ss2
    <span class="c">(* /\ he2 = hs2 *)</span>
    /\ compatible rs re.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">se1</span> : store) (<span class="nv">he1</span> : heap) (<span class="nv">e</span> : expr)
  (<span class="nv">se2</span> : store) (<span class="nv">he2</span> : heap) (<span class="nv">re</span> : eresult) (<span class="nv">f</span> : flow)
  (<span class="nv">ss1</span> : Common.store Z) (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store)
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
<span class="kp">eval</span>[ se1, he1, e]=&gt; [se2, he2, re] -&gt;
substore se1 ss1 -&gt;
forward e f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore se2 ss2 /\ compatible rs re</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">se1</span> : store) (<span class="nv">he1</span> : heap) (<span class="nv">e</span> : expr)
  (<span class="nv">se2</span> : store) (<span class="nv">he2</span> : heap) (<span class="nv">re</span> : eresult) (<span class="nv">f</span> : flow)
  (<span class="nv">ss1</span> : Common.store Z) (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store)
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
<span class="kp">eval</span>[ se1, he1, e]=&gt; [se2, he2, re] -&gt;
substore se1 ss1 -&gt;
forward e f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore se2 ss2 /\ compatible rs re</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk80"><span class="nb">intros</span> se1 he1 e se2 he2 re
          f ss1 hs1 ss2 hs2 rs
          Hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>se1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>he1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>se2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>he2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>re</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ se1, he1, e]=&gt; [se2, he2, re]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore se1 ss1 -&gt;
forward e f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore se2 ss2 /\ compatible rs re</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk81"><span class="nb">revert</span> f ss1 hs1 ss2 hs2 rs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>se1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>he1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>se2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>he2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>re</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ se1, he1, e]=&gt; [se2, he2, re]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z) (<span class="nv">hs1</span> : heap)
  (<span class="nv">ss2</span> : store) (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore se1 ss1 -&gt;
forward e f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore se2 ss2 /\ compatible rs re</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk82"><span class="nb">induction</span> Hb;
  <span class="nb">intros</span> f ss1 hs1 ss2 hs2 rs;
  <span class="nb">intros</span> Hsub Hf Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>forward (pvar x) f</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible rs (enorm v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>forward (pconst x) f</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs f</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk83"><hr></label><div class="goal-conclusion">substore s ss2 /\ compatible rs (enorm x)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Flow-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>forward (plet x e1 e2) f</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs f</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk84"><hr></label><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk85">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>forward (pvar x) f</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible rs (enorm v)</div></blockquote></div></div></small></span><span class="alectryon-wsp"> <span class="c">(* var. the proof comes down to the fact that both spec and program read</span>
<span class="c">        s(x) and leave the heap unchanged. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk86">inv Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs
  (ens
     (<span class="kr">fun</span> (<span class="nv">res</span> : Z) (<span class="nv">s</span> : Common.store Z)
        (<span class="nv">h</span> : heap) =&gt;
      <span class="kr">exists</span> <span class="nv">v</span> : Z,
        s x = Some v /\ res = v /\ emp s h))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible rs (enorm v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk87">inv Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z,
  ss2 x = Some v /\ v0 = v /\ emp ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible (norm v0) (enorm v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk88">destr_all; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>emp ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible (norm H0) (enorm v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk89"><span class="nb">intuition</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>emp ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">compatible (norm H0) (enorm v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8a"><span class="nb">unfold</span> compatible.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>emp ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H0 = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8b"><span class="nb">unfold</span> emp <span class="kr">in</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>h3 = hempty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H0 = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8c"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 hempty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H0 = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8d"><span class="nb">unfold</span> substore <span class="kr">in</span> Hsub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some v = s x</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">v</span> : Z) (<span class="nv">x</span> : ident),
s x = Some v -&gt; ss2 x = Some v</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 hempty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H0 = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8e"><span class="nb">symmetry in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>s x = Some v</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">v</span> : Z) (<span class="nv">x</span> : ident),
s x = Some v -&gt; ss2 x = Some v</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 hempty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H0 = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk8f"><span class="nb">specialize</span> (Hsub v x H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; option Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>s x = Some v</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>ss2 x = Some v</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 hempty</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>ss2 x = Some H0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H0 = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk90">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>forward (pconst x) f</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible rs (enorm x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk91">inv Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs
  (ens (<span class="kr">fun</span> <span class="nv">res</span> : Z =&gt; (res = x) //\\ emp))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible rs (enorm x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk92">inv Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>((v = x) //\\ emp) ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ compatible (norm v) (enorm x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk93"><span class="nb">unfold</span> compatible.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>((v = x) //\\ emp) ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ v = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk94"><span class="nb">unfold</span> pureconj <span class="kr">in</span> Hq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss2</span></span></span><br><span><var>h3</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>hdisjoint hs1 h3</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>v = x /\ emp ss2 h3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s ss2 /\ v = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span> <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk95">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>forward (plet x e1 e2) f</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* we have an IH for each subexpr *)</span>
    <span class="c">(* v is the intermediate result of evaluating e1 *)</span>
    <span class="c">(* r is the final result *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk96">inv Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>satisfies ss1 hs1 ss2 hs2 rs (compose x f1 f2)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* the spec is of the form ex x. f1[x/r];f2 *)</span>
    <span class="c">(* see how it evaluates *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk97">inv Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">v</span> : Z,
  satisfies (supdate x v ss1) hs1 ss2 hs2 rs
    (replace_ret x f1;; f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk98"><span class="nb">destruct</span> Hex <span class="kr">as</span> [v1 Hseq].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hseq</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 ss2 hs2 rs
  (replace_ret x f1;; f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* v1 is the return value of f1, which can be anything due to replace ret *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk99">inv Hseq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* reason about replace_ret using the freshness of existentials *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk9a"><span class="nb">pose proof</span> (satisfies_replace_ret f1 x v1 (supdate x v1 ss1) hs1 s4 h4 r1) <span class="kr">as</span> Hrr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 -&gt;
supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk9b">forward Hrr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 -&gt;
supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow x f1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><label class="goal-separator" for="Flow-v-chk9c"><hr></label><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk9d">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 -&gt;
supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow x f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk9e"><span class="nb">simpl</span> <span class="kr">in</span> Hfresh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1) /\
fresh_in_flow x f2</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 -&gt;
supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow x f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chk9f"><span class="nb">destruct</span> Hfresh <span class="kr">as</span> [Hfresh _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x f1 -&gt;
supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fresh_in_flow x f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (fresh_replace _ _ _ Hfresh).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>supdate x v1 ss1 x = Some v1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka1">forward Hrr <span class="bp">by</span> <span class="nb">apply</span> supdate_same.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1) -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka2"><span class="nb">specialize</span> (Hrr Hs1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>Hfresh</var><span class="hyp-type"><b>: </b><span>fresh_in_flow x (replace_ret x f1;; f2)</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka3"><span class="nb">clear</span> Hfresh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore s ss1 -&gt;
forward e1 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s1 ss2 /\ compatible rs (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* apply IH1 to know that all of e1 is sound *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka4"><span class="nb">specialize</span> (IHHb1 f1 (supdate x v1 ss1) hs1 s4 h4 (norm v1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span>substore s (supdate x v1 ss1) -&gt;
forward e1 f1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4
  (norm v1) f1 -&gt;
substore s1 s4 /\
compatible (norm v1) (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka5">forward IHHb1 <span class="bp">by</span> <span class="nb">apply</span> substore_extension_trans <span class="kr">with</span> (s2:=ss1); <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span>forward e1 f1 -&gt;
satisfies (supdate x v1 ss1) hs1 s4 h4
  (norm v1) f1 -&gt;
substore s1 s4 /\
compatible (norm v1) (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka6"><span class="nb">specialize</span> (IHHb1 H3 Hrr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>IHHb1</var><span class="hyp-type"><b>: </b><span>substore s1 s4 /\
compatible (norm v1) (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka7"><span class="nb">destruct</span> IHHb1 <span class="kr">as</span> [Hst Hcomp].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>v1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>Hcomp</var><span class="hyp-type"><b>: </b><span>compatible (norm v1) (enorm v)</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v1 ss1) hs1 s4 h4 
  (norm v1) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka8"><span class="nb">unfold</span> compatible <span class="kr">in</span> Hcomp; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">f</span> : flow) (<span class="nv">ss1</span> : Common.store Z)
  (<span class="nv">hs1</span> : heap) (<span class="nv">ss2</span> : store) 
  (<span class="nv">hs2</span> : heap) (<span class="nv">rs</span> : result),
substore (supdate x v s1) ss1 -&gt;
forward e2 f -&gt;
satisfies ss1 hs1 ss2 hs2 rs f -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* apply IH2 to know that the entire thing is sound *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chka9"><span class="nb">specialize</span> (IHHb2 f2 s4 h4 ss2 hs2 rs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>substore (supdate x v s1) s4 -&gt;
forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkaa">forward IHHb2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>substore (supdate x v s1) s4 -&gt;
forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore (supdate x v s1) s4</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Flow-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><label class="goal-separator" for="Flow-v-chkab"><hr></label><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkac">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>substore (supdate x v s1) s4 -&gt;
forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore (supdate x v s1) s4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkad"><span class="nb">pose proof</span> (satisfies_monotonic _ _ _ _ _ _ Hs1) <span class="kr">as</span> Hmono.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>substore (supdate x v s1) s4 -&gt;
forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br><span><var>Hmono</var><span class="hyp-type"><b>: </b><span>substore (supdate x v ss1) s4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore (supdate x v s1) s4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkae"><span class="nb">specialize</span> (substore_extension_left _ s1 s4 v x Hst) <span class="kr">as</span> Hsub1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>substore (supdate x v s1) s4 -&gt;
forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br><span><var>Hmono</var><span class="hyp-type"><b>: </b><span>substore (supdate x v ss1) s4</span></span></span><br><span><var>Hsub1</var><span class="hyp-type"><b>: </b><span>s4 x = Some v -&gt; substore (supdate x v s1) s4</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore (supdate x v s1) s4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">now</span> forward Hsub1 <span class="bp">by</span> <span class="nb">apply</span> (substore_extension_inv _ _ _ _ _ Hmono).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkaf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>forward e2 f2 -&gt;
satisfies s4 h4 ss2 hs2 rs f2 -&gt;
substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Flow-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="Flow-v-chkb0"><span class="nb">specialize</span> (IHHb2 H4 Hs2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h, h2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>s2, s1</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>eresult</span></span></span><br><span><var>Hb1</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ s, h, e1]=&gt; [s1, h1, enorm v]</span></span></span><br><span><var>Hb2</var><span class="hyp-type"><b>: </b><span><span class="kp">eval</span>[ supdate x v s1, h1, e2]=&gt; [s2, h2, r]</span></span></span><br><span><var>ss1</var><span class="hyp-type"><b>: </b><span>Common.store Z</span></span></span><br><span><var>hs1</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>s4</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>h4</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>Hst</var><span class="hyp-type"><b>: </b><span>substore s1 s4</span></span></span><br><span><var>ss2</var><span class="hyp-type"><b>: </b><span>store</span></span></span><br><span><var>hs2</var><span class="hyp-type"><b>: </b><span>heap</span></span></span><br><span><var>rs</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flow</span></span></span><br><span><var>IHHb2</var><span class="hyp-type"><b>: </b><span>substore s2 ss2 /\ compatible rs r</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>substore s ss1</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>forward e1 f1</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>forward e2 f2</span></span></span><br><span><var>Hnotin</var><span class="hyp-type"><b>: </b><span>ss1 x = None</span></span></span><br><span><var>r1</var><span class="hyp-type"><b>: </b><span>result</span></span></span><br><span><var>Hs1</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 r1
  (replace_ret x f1)</span></span></span><br><span><var>Hs2</var><span class="hyp-type"><b>: </b><span>satisfies s4 h4 ss2 hs2 rs f2</span></span></span><br><span><var>Hrr</var><span class="hyp-type"><b>: </b><span>satisfies (supdate x v ss1) hs1 s4 h4 
  (norm v) f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">substore s2 ss2 /\ compatible rs r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>